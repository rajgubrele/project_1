# -*- coding: utf-8 -*-
"""QR_factorization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/138OgvUl4auVJ2E3iD8xF0lc99nrpQceG
"""

###########################################################################      qr_Factorization.py     ###########################################
# Module Script File
# QR factorization method to find the eigen value of a square matrix is an iterative method
# It uses the Classical Gram-Schmidt Orthogonalization
# Q matrix is orthogonal in nature and R matrix is upper triangular in nature 
####################################################################################################################################################
# The following function performs QR factorization of given matrix "A" and returns the Eigen values
# Usage:  Eigen_values, Iterations =  QR(A, n, max_iter, int_iter, Tolerance)
# This function takes A,n,int_iter,max_iter, Tolerance as variable (or argument)
# Where; A =  the problem matrix, and it is a numpy array of order n
# n = order of A matrix, 
# max_iter = maximum limit of iterations and this is a integer, 
# int_iter = boolean variable which decides whether to print intermidiate iteration or not,
# Tolerance = how much close to zero the lower diagonal elements must be to achieve convergence and this is float type 
#####################################################################################################################################################
# The outputs:-                                                                 
# The outputs of this function are total number of iteration, all the eigen values and final upper triangular matrix.
# On condition of "True" int_iter it provides intermediate iteration: the number of iterations, A1 (matrix got after each iteration), Q  and R matrix respectively
#####################################################################################################################################################
# Example for using the module:
#  import qr_factorization as qrf  # Importing the QR module
#  import numpy as np # Import Numpy library as np
#  A = np.array([[1,2,0,0,0],[2,1,2,0,0],[0,2,1,2,0],[0,0,2,1,2],[0,0,0,2,1]])  # Given Problem Matrix
#  n = len(A)      # Give the order of the square matrix
#  Tolerance = 0.9898 # Tolerance argument to achieve convergence
#  max_iter = 8000         # Max number of allowed itreation upto user wants to iterate                                                   
#  int_iter = True  #Enter  "True" for printing intermidiate iterations and "False" for not printing    
#  qrf.QR(A, n, max_iter, int_iter, Tolerance)  # Calling the function
#####################################################################################################################################################



import numpy as np  # importing NumPy library as np
import math        # importing Math library

def QR(A, n, max_iter, int_iter, Tolerance):                          # Defining the QR Module which will be imported in input file   
  def Norm(X):                                                        # Defining the norm of a vector
    m = 0
    for z in range(0, n):
      m = m + (X[z])*(X[z])
   
    return np.sqrt(m)


  def Gram_sch(A):                                                    # Defining the function which does QR factor of a square matrix By Gram-Schmidt Method
    n, n = A.shape                                                    # A (Input matrix) is a square matrix
    Q = np.zeros([n,n])                                               # Create n*n array with float zeros
    R = np.zeros([n,n])
    for j in range(n):
      v = A[:,j]                                                      # v is j th column vector of A 
      for i in range(j):
        R[i,j] = np.dot(Q[:,i], A[:,j])                               # dot product i th column vector of Q with j th column vector of A
        v = v - (R[i,j]*Q[:,i])
      R[j,j] = Norm(v)
      Q[:,j] = v/R[j,j]                                               # Orthogonalization of the column vectors of Q 
    return Q,R

  def matrix_check(M):                                                # Function to check how close are the lower diagonal elements to zero, a check for convergence
    u = 0
    for p in range(1, n):
     for q in range(0, p):
       if  math.isclose(M[p][q], 0, abs_tol = Tolerance):             # abs_tol stands for absolute tolerance to be given in the input file
        u = u + 1
    return u   
        

  def Principal_Diag(mat, n):                                         # Defining the function which prints the Principal diagonal
    Diag = []                                                         # The diagonal elements of the final matrix which are actually the eigen values are appended in this list
    for s in range(n):
         for p in range(n):          
             if (s == p):
               Diag.append(mat[s][p])
    return Diag
 

  def getting_Eigen(A):                                                #Defining the Function which does QR algorithm  
    A1 = np.copy(A)
    #QQ = np.eye(n)
    k = 0
    out = open("QR_method.txt", "w")                                      # Opening the txt file for writing the output
    while matrix_check(A1) < n*(n-1)/2 and k<=max_iter:                # n*(n-1)/2 is the number of lower diagonal elements of nth order square matrix
      Q,R = Gram_sch(A1)                                               # When all the lower diagonal elements are close to zero (decided by tolerance) loop ends
      A1 = R @ Q  # '@' for matrix multiplication                      # Loop also ends when convergence is not achieved within maximum iteration limit (max_iter)
    
      if int_iter == True:                                             # prints the intermidiate results if "True" written in input.py
        print('Iteration no: {}'.format(k), file = out)                # Prints intermidiate iteration number
        print('A1 is:\n {}'.format(A1),  file = out)                   # Prints intermidiate A1 matrices
        np.set_printoptions(precision=3)
        print('\n', file = out)
        print('Q is \n {}'.format(Q), file = out)                      # Prints intermidiate Q matrices
        np.set_printoptions(precision=3)
        print('\n', file = out)
        print('R is \n{}'.format(R), file = out)                       # Prints intermidiate R matrices
        np.set_printoptions(precision=3)
        print('\n ----------------------------------------------------------------------------------------------------------',  file = out)
        k = k + 1

     
    print("Final A1 is \n {}".format(A1), file = out)                  #prints final A1 matrix
    np.set_printoptions(precision=3)
    print("Total no. of Iterations: {}".format(k-1), file = out)       #Prints total number of iterations 
    print("Eigen Values are: {}".format(Principal_Diag(A1, n)), file = out)   # Prints the Eigen values
    np.set_printoptions(precision=3) 
    out.close()
 
  out = open("QR_method.txt", "a")  
  print(getting_Eigen(A), file = out)  
  out.close()